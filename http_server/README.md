# HTTP服务器文档

## 日志系统

server使用的日志系统是一个轻量级的简易日志系统。用户可以调用头文件`Log.h`中提供了四个全局函数`log_debug()`、`log_info()`、`log_warn()`、`log_error()`在控制台上输出不同级别的日志。由于日志系统全局只需要有一个，因此这里使用单例模式（线程安全的懒汉模式）来实现日志系统。日志系统在析构时需要将目前日志队列中的所有日志取出并输出。

日志系统的输出有四种级别，从低到高分别是：debug、info、warn、error，用户可以在配置文件`config.ini`中指定日志系统当前的输出级别，只有级别不低于指定级别的日志才会被输出（例如在配置文件中指定日志系统当前的输出级别为info，则debug级别的日志在程序实际运行时并不会被输出）。

日志系统有同步和异步两种工作方式，用户也可以在配置文件`config.ini`中指定其工作模式。对于同步模式下的日志系统，当用户调用【日志输出函数】时，程序会同步的将日志打印到控制台上。由于IO是一个比较耗时的操作，频繁的日志IO会导致服务器性能的下降，因此在用户调用【日志输出函数】时，我们先将要打印的日志加到日志队列中，交给一个子线程去IO。

在负责写日志的子线程中，不断的判断日志队列是否为空，如果不为空，则取出日志并输出；如果为空，则使用条件变量阻塞线程（防止线程忙等）。将日志添加到日志队列时，如果发现子线程被阻塞了，则需要唤醒子线程。

注：由于queue是线程不安全的，因此在操作queue时必须加锁，这会导致异步日志系统没法达到应有的性能，下一步的优化方向是使用双缓冲机制实现日志系统（基本思路是，使用两个日志队列A和B，初始时主线程一直向A中写日志，待A写满后，主线程再向B中写日志，此时子线程负责将A中的日志输出。之后主线程再向A中写日志，子线程负责将B中的日志输出，如此循环）。

## 线程池

server使用的线程池是一个轻量级的简易线程池。线程池的主要意义在于直接利用提前构建好的子线程（子线程的数量一般和CPU总核心数相同或接近）处理任务，避免线程频繁创建和销毁的开销。线程池和日志系统一样，采用了单例模式实现。线程池在析构时需要将目前任务队列中的所有任务取出并执行。

在初始化线程池时，就需要根据配置文件`config.ini`中指定的线程数量将子线程预先创建好。由于queue是线程不安全的，因此在操作任务队列时必须要加锁。和日志系统不同的是，任务task的执行时间可能很长，有些任务甚至是无限循环，如果不释放掉之前加的锁，就会导致死锁的产生（例如一个工作线程获取锁后执行一个死循环任务，由于该线程没有释放锁，导致其他的工作线程都阻塞在锁的获取上，从而无法从任务队列中取出任务并执行）。又考虑到加锁的目的仅是为了保证操作任务队列时的线程安全，因此将任务取出队列后，就可以先解锁再执行任务，待任务执行完成后，再重新加锁。代码如下：

```c++
std::unique_lock<std::mutex> lock(ThreadPool::instance()->poolLock);
if(!ThreadPool::instance()->taskQue.empty()){
    // 从任务队列中取出任务并执行
    auto task=ThreadPool::instance()->taskQue.front();
    ThreadPool::instance()->taskQue.pop();
    lock.unlock(); // 暂时解锁
    task();
    lock.lock(); // 重新加锁
}else ThreadPool::instance()->condvar.wait(lock); // 如果任务队列为空，则该线程阻塞
```

主线程使用`addTask`函数向任务队列中添加任务，由于queue是线程不安全的，因此在添加任务时必须先加锁。主线程中可以使用`std::bind`将可调用对象及参数封装成一个`function`对象传给`addTask`函数。

注：线程池进一步优化的方向是：使用合理的线程轮转算法，让各个线程的负载尽量相差不大，避免某个或某些线程过载。

对于C++ 11 而言，使用多线程需要包含头文件`#include <thread>`，并且在链接时需要用到`pthread`库。

## 自增长缓冲区

server使用一个简易的自增长缓冲区。缓冲区分为三个部分：`0～readPos：暂时没有被使用的空间`、`readPos～writePos：可以读的空间（可以把这部分数据读到文件中）`、`writePos～buffer.size：可以写的空间（可以将文件中的数据写到这部分空间中）`。

缓冲区对外提供了五个操作函数：`readFromFile`函数用于从文件中读数据到写空间、`writeToFile`函数用于从读空间向文件中写数据、`appendData`函数用于向可写空间中追加数据、`getData`函数用于取出可读空间中的数据、`readData`用于查看可读空间中的数据。

`writeToFile`的实现较为简单，直接将缓冲区读空间中的可读字节写到文件中即可；`readFromFile`函数的实现则较为复杂，首先我们创建一个足够大的临时缓冲区，并利用分散读将文件中的数据读到Buffer和临时缓冲区中。如果从文件中读出的数据较少，少于Buffer当前可用的字节数，则Buffer无需扩容；否则需要将Buffer扩容。其余函数的实现原理类似。

## 定时器

server使用的是一个基于小根堆的定时器，定时器中每个节点保存了该节点的id，到期时间，到期时的回调函数。小根堆的堆顶是到期时间最近的节点。小根堆底层使用vector实现，并且使用了一个map记录节点的id到节点在vector中索引的映射，方便根据节点id快速确定节点的位置。由于小根堆底层是使用vector实现的，因此需要自行实现小根堆中节点位置的调整，以及取出小根堆堆顶的代码。

定时器总共提供了四个函数可供外部程序调用：更新一个结点的到期时间、添加一个结点、获取距离最近的到期时间的毫秒数、根据id删除一个制定的节点。

## 客户端连接封装

本项目中对客户端的连接进行了一定的封装。每个Connection对象中保存了该客户端连接对应的文件描述符、客户端的IP地址和端口、一个可以自动增长的读缓冲区和一个可以自动增长的写缓冲区、HTTP请求头中的重要字段（例如keep-alive）。

Connection类有三个主要的方法：`readFromFile`方法用于将数据从通信套接字的读缓冲区中读到Connection的读缓冲中、`process`方法将会调用HTTP处理器（`HttpProcess`）的方法process，解析读缓冲区中的数据，并将解析结果传递给Python路由器（`prouter`），Python路由器调用相应的处理函数进行业务处理，最后将处理结果返回给process函数，process函数需要根据返回的结果，构造HTTP响应，并将其写入到Connection的写缓冲中。`writeToFile`方法用于将写缓冲中的数据写到通信套接字的写缓冲区中（由内核将这些数据发送出去）。

## HTTP处理器

HTTP解析器：逐个字节的读取缓冲区中的数据，如果读到了`\r\n`，则取出该行进行解析。如果当前正在解析请求行，使用一个正则表达式取出请求行中的HTTP版本、请求方法和URL，并将状态设置为解析请求头；如果当前正在解析请求头，使用一个正则表达式取出请求头中的键和值（并把键中的单词的首字母统一设置为小写）；如果某行请求头解析完成后，又读取到了一个空行`\r\n`，则继续解析请求体（请求体的长度在请求头`content-length`中可以得到），如果发现缓冲区中的数据不足以取出指定的大小的请求体，则放弃本次解析，等待后续数据到达。

HTTP构造器：根据HTTP协议版本、状态码和状态描述构造响应行。如果是长连接，则添加响应头`Connection: keep-alive`；由于服务器只支持`json`数据，因此要添加`Content-Type: application/json`响应头；由于服务器只支持GET、POST方法，因此要添加`Access-Control-Allow-Methods: GET,POST`；还要根据响应体的长度添加`Content-Length`响应头。最后，在添加一个空行`\r\n`后添加响应体。

HTTP处理器：先调用HTTP解析器进行HTTP报文的解析，如果解析失败（即报文不完整），则放弃解析，等待后续报文的到达；如果解析成功，先判断是否存在异常情况（比如请求方法不支持等），并返回相应的报文；如果没有异常请求，则要调用Processor的process函数，将HTTP解析结果传递给process函数，进行处理，并根据process函数的返回结果封装相应的报文（函数返回"404"，则返回404报文；函数返回空字符串""，则返回500报文；其他情况返回200报文）。

## 服务器模型

本项目的服务器是基于Reactor并发模型的（主线程只负责accept请求，具体读写和处理任务分发给其它IO线程(兼计算线程)），使用epoll循环检测文件描述符的就绪状态。如果有文件描述符就绪，就依次进行处理：如果是监听套接字就绪，就取出通信套接字的文件描述符并保存起来；如果是读事件就绪，则将相应的方法加到任务队列中，由线程池中的线程依次处理；如果是写事件就绪，也将相应的方法加到任务队列中，由线程池中的线程依次处理。

以下是一些需要注意的细节：

* 本项目中，监听套接字使用水平触发模式（LT），因此不需要循环使用accept进行检测，而通信套接字使用边沿触发模式（ET），因此需要循环使用read读取数据。监听套接字和通信套接字都注册了`EPOLLRDHUP`事件的监听，以可以感知客户端的情况。除此之外，通信套接字还注册了`EPOLLONESHOT`，保证每次就绪时只会触发一次（除非重置监听事件），保证了同时只有一个线程能操作一个socket。
* 本项目中，监听套接字和通信套接字对应的文件描述符都设置为非阻塞的，这是为了防止某个文件描述符的读写阻塞导致其他用户被饿死。
* 在初始化监听套接字时，设置了端口复用和优雅关闭选项。
* 对于客户端的关闭，有两种情况，一种是客户端超时未连接，服务器自动将其清除掉；另一种是客户端主动断开连接。这两种客户端断开连接的情况要使用不同的清理函数释放系统资源（分别是`connectTimeout`和`disconnect`）。
